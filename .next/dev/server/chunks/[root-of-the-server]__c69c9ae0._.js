module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/querystring [external] (querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}),
"[externals]/stream/web [external] (stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream/web", () => require("stream/web"));

module.exports = mod;
}),
"[externals]/worker_threads [external] (worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("worker_threads", () => require("worker_threads"));

module.exports = mod;
}),
"[externals]/perf_hooks [external] (perf_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("perf_hooks", () => require("perf_hooks"));

module.exports = mod;
}),
"[externals]/util/types [external] (util/types, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util/types", () => require("util/types"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/diagnostics_channel [external] (diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("diagnostics_channel", () => require("diagnostics_channel"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/http2 [external] (http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/async_hooks [external] (async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("async_hooks", () => require("async_hooks"));

module.exports = mod;
}),
"[externals]/console [external] (console, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("console", () => require("console"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/app/api/report/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$blob$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@vercel/blob/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
;
;
// Cache for access token
let tokenCache = null;
let lastRefreshAttempt = 0;
const MIN_REFRESH_INTERVAL = 60000 // 60 seconds minimum between refresh attempts
;
let rateLimitUntil = 0 // Timestamp when rate limit expires
;
async function getAccessToken(forceRefresh = false) {
    // Check if we're currently rate limited
    if (rateLimitUntil > Date.now()) {
        const waitSeconds = Math.ceil((rateLimitUntil - Date.now()) / 1000);
        throw new Error(`RATE_LIMITED:${waitSeconds}`);
    }
    // Check if we have a valid cached token (unless forcing refresh)
    if (!forceRefresh && tokenCache && tokenCache.expiresAt > Date.now()) {
        console.log("[cruising-fleet] Using cached token");
        return tokenCache.token;
    }
    const now = Date.now();
    if (now - lastRefreshAttempt < MIN_REFRESH_INTERVAL) {
        console.log("[cruising-fleet] Rate limit protection: Using cached token to avoid Zoho rate limit");
        if (tokenCache) {
            return tokenCache.token;
        }
        const waitSeconds = Math.ceil((MIN_REFRESH_INTERVAL - (now - lastRefreshAttempt)) / 1000);
        throw new Error(`RATE_LIMITED:${waitSeconds}`);
    }
    lastRefreshAttempt = now;
    const params = new URLSearchParams({
        grant_type: "refresh_token",
        client_id: process.env.ZOHO_CLIENT_ID,
        client_secret: process.env.ZOHO_CLIENT_SECRET,
        refresh_token: process.env.ZOHO_REFRESH_TOKEN
    });
    console.log("[cruising-fleet] Requesting new access token from Zoho");
    const response = await fetch("https://accounts.zoho.com/oauth/v2/token", {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params.toString()
    });
    if (!response.ok) {
        const errorBody = await response.text();
        console.error("[cruising-fleet] Token refresh failed:", response.status, errorBody);
        if (response.status === 400 && errorBody.includes("too many requests")) {
            console.log("[cruising-fleet] Rate limited by Zoho, setting rate limit period");
            // Set rate limit for 2 minutes
            rateLimitUntil = Date.now() + 2 * 60 * 1000;
            const waitSeconds = 120;
            throw new Error(`RATE_LIMITED:${waitSeconds}`);
        }
        throw new Error(`Failed to refresh access token: ${response.status}`);
    }
    const data = await response.json();
    console.log("[cruising-fleet] Successfully got new access token");
    // Cache the token (expires in 1 hour, we'll cache for 50 minutes to be safe)
    tokenCache = {
        token: data.access_token,
        expiresAt: Date.now() + 50 * 60 * 1000
    };
    return data.access_token;
}
async function fetchReportData(accessToken) {
    const ownerEmail = process.env.ZOHO_OWNER_EMAIL;
    const workspaceName = encodeURIComponent(process.env.ZOHO_WORKSPACE_NAME);
    const reportName = encodeURIComponent(process.env.ZOHO_REPORT_NAME);
    const url = `https://analyticsapi.zoho.com/api/${ownerEmail}/${workspaceName}/${reportName}?ZOHO_ACTION=EXPORT&ZOHO_OUTPUT_FORMAT=JSON&ZOHO_ERROR_FORMAT=JSON&ZOHO_API_VERSION=1.0`;
    const response = await fetch(url, {
        headers: {
            Authorization: `Zoho-oauthtoken ${accessToken}`
        }
    });
    return response;
}
async function syncZohoData() {
    console.log("[cruising-fleet] Syncing fresh data from Zoho...");
    const accessToken = await getAccessToken();
    const response = await fetchReportData(accessToken);
    if (!response.ok) {
        const errorText = await response.text();
        console.error("[cruising-fleet] Zoho API error:", errorText);
        throw new Error(`Failed to fetch report data: ${response.status}`);
    }
    const rawText = await response.text();
    // Fix common JSON escaping issues
    const cleanedText = rawText.replace(/\\/g, "\\\\").replace(/\\\\"/g, '\\"').replace(/\\\\n/g, "\\n").replace(/\\\\t/g, "\\t").replace(/\\\\r/g, "\\r");
    let data;
    try {
        data = JSON.parse(cleanedText);
    } catch (parseError) {
        console.error("[cruising-fleet] JSON parse error with cleaned text, trying original:", parseError);
        data = JSON.parse(rawText);
    }
    // Delete all existing blobs before writing the new one
    const { blobs: existingBlobs } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$blob$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["list"])({
        prefix: "cruising-fleet-zoho-report-blob"
    });
    if (existingBlobs.length > 0) {
        console.log(`[cruising-fleet] Deleting ${existingBlobs.length} existing blob(s)`);
        await Promise.all(existingBlobs.map((blob)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$blob$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["del"])(blob.url)));
    }
    // Write to Vercel Blob
    const blob = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$blob$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["put"])("cruising-fleet-zoho-report-blob.json", JSON.stringify(data), {
        access: "public",
        contentType: "application/json",
        addRandomSuffix: true
    });
    console.log("[cruising-fleet] Successfully synced data to Blob:", blob.url);
    return data;
}
async function GET() {
    try {
        const { blobs } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$blob$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["list"])({
            prefix: "cruising-fleet-zoho-report-blob"
        });
        if (blobs.length === 0) {
            console.log("[cruising-fleet] No cached data found in Blob storage, fetching fresh data...");
            try {
                const data = await syncZohoData();
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(data);
            } catch (syncError) {
                console.error("[cruising-fleet] Failed to sync data:", syncError);
                // Check if it's a rate limit error
                if (syncError instanceof Error && syncError.message.startsWith("RATE_LIMITED:")) {
                    const waitSeconds = Number.parseInt(syncError.message.split(":")[1]);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        error: `Zoho API rate limit reached. Please wait ${waitSeconds} seconds and refresh the page.`
                    }, {
                        status: 429,
                        headers: {
                            "Retry-After": waitSeconds.toString()
                        }
                    });
                }
                throw syncError;
            }
        }
        // Get the most recent blob (they're sorted by uploadedAt by default)
        const latestBlob = blobs[0];
        console.log("[cruising-fleet] Reading cached data from Blob:", latestBlob.pathname);
        // Fetch the blob content
        const response = await fetch(latestBlob.downloadUrl);
        if (!response.ok) {
            throw new Error(`Failed to fetch blob: ${response.status}`);
        }
        const data = await response.json();
        console.log("[cruising-fleet] Blob data retrieved:", JSON.stringify({
            uploadedAt: latestBlob.uploadedAt,
            hasResponse: !!data.response,
            rowCount: data.response?.result?.rows?.length || 0
        }, null, 2));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(data);
    } catch (error) {
        console.error("[cruising-fleet] Error fetching cached report:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Failed to fetch cached report data"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__c69c9ae0._.js.map